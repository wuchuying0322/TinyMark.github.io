---
title: JS中三种函数声明方式及函数变量重名问题
tags: 函数声明方式
categories: 
- FrontEnd
- JavaScript
---

** keywords：预解析、变量提升、函数提升、初始化 **

# 函数声明 方式（function关键字声明）

		function fn1(n1,n2){
		    return n1+n2;
		};

<!-- more --> 

# 函数表达式（var变量声明）
** 又叫函数字面量 方式：**

		var fn2 = function(n1,n2){
		    return n1+n2;
		};

# **两者的区别：**
		
**函数声明方式会被JS预解析，然后函数提升，结果是使其在执行任何代码之前可以访问；**
		
**而函数表达式在预解析时，只有变量提升，必须等到解析器执行到它所在的代码行时才会真正被解释执行。**

* **关于JS预解析：**
	
	在当前作用域下,js运行之前，会把带有var和function关键字的事先声明，并在内存中安排好。然后再从上到下执行JS代码。

* ** 变量提升/函数提升(Hoisting)**
		
	变量提升：JS会把所有在当前作用域通过var声明的变量提升到当前作用域的最顶层进行预解析，然后再从上到下执行JS代码。
		
	函数提升：JS会把所有在当前作用域通过 函数声明方式（function关键字声明的）创建的函数的函数体，
	提升到当前作用域的最顶层进行预解析（！函数表达式 是var变量声明的，所以属于变量提升，函数体并没有被提升！）

	[关于 作用域-闭包 的理解](https://tinymark.github.io/2017/03/12/JS/%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85/)
	

* **例子：**

		var foo = 1;
		function fn(){
		    console.log(foo); 
		    var foo = 2;
		    console.log(foo); 
		}
		fn(); 
		> undefined
		> 2
		
		JS中会这样解析：
		function fn(){...};var foo;	// 1、函数提升；变量提升；
		foo = 1; 					// 2、变量赋值
		fn(); 						// 3、函数调用，开始执行函数体{...}
		{
		    var foo;    			// 4、变量声明提升到函数作用域顶部
		    console.log(foo);		// 5、输出 undefined
		    foo = 2;    			// 6、变量赋值
		    console.log(foo);		// 7、输出 2
		}



# 函数构造法，参数必须加 引号 （基本不用）
	
		var sum3=new Function('n1','n2','return n1+n2');
			console.log(sum3(2,3));

从技术角度讲，这是一个函数表达式。一般不推荐用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的字符串），从而影响性能。

		var name='haoxl';
		function fun(){
		var name='lili';
		return new Function('return name');	//不能获取局部变量
		}
		console.log(fun()());				// haoxl

 Function()构造函数每次执行时都会解析函数主体，并创建一个新的函数对象，所以当在一个循环或频繁执行的函数中调用Function()构造函数效率是非常低的。而函数字面量却不是每次遇到都会重新编译的，用Function()构造函数创建一个函数时并不遵循典型的作用域，它一直把它当作是顶级函数来执行。

# 总结、重名问题：
##  变量声明提升：变量申明在进入JS代码执行之前就完成了
##  两种函数声明方式：
* 函数声明方式：函数是JS中的一等公民，会把整个函数体提升到作用域的最前面，所以可以把函数声明放到 ** 调用语句 ** 的后面；

* 函数表达式：等同变量声明，只会提升函数名变量


## 变量or函数声明重名：函数声明会覆盖变量声明，但不会覆盖变量初始化
* 函数的两种声明方式都会覆盖同名的变量声明！
* 但是一旦变量初始化（例如赋值操作），同名变量即会覆盖同名函数！